<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <title>Docker Basics</title>
  </head>
  <body>
    <h1>Tutorial Básico de Docker</h1>
    <h2>Baseada nas video aulas do usuário do youtube LINUXtips.</h2>
    <p>Primeiro é preciso verificar se o Kernel do seu linux é 3.8. Veja isso digitando no terminal uname -r</p>
    <p><a href="https://docs.docker.com/engine/install/ubuntu/">Instalar o Docker.</a></p>
    <p>Iniciar o Docker: /etc/init.d/docker start</p>
    <p>Checar se o Docker está funcionando: ps -ef | grep docker</p>
    <ul>
      <li>grep = procura por trechos de texto (strings) dentro de arquivos ou diretórios e retorna para você em quais arquivos a string foi encontrada, inclusive mostrando a linha em que isso ocorreu.</li>
    </ul>
    <p>Informa os containers que estão rodando no momento: docker ps</p>
    
    <h3>Entendendo as saídas do 'docker ps':</h3>
    <ul>
      <li>CONTAINER ID: identificação do container</li>
      <li>IMAGE: imagem que o container está utilizando</li>
      <li>COMMAND: qual o comando que o container está executando</li>
      <li>CREATED: há quanto tempo o container foi criado</li>
      <li>STATUS: identifica há quanto tempo ele está executando</li>
      <li>PORTS: a porta em que a imagem está sendo executada </li>
      <li>NAMES: nome do container </li>
    </ul>
    <p>Ver as imagens que estão na máquina: docker images</p>
    <p>Criando um container ubuntu: docker run -i -t ubuntu:14.10 /bin/bash</p>
    <ul>
      <li>Mais sobre esse tópico: ubuntu:14.10 /bin/bash (distro:versão comando-a-ser-executado)</li>
    </ul>
    <p>Após fazer o download o sistema já estará rodando noutra máquina, você pode verificar isso através do comando cat /etc/issue</p>
    <ul>
      <li>OBS: lembrando que ainda se trata de um container, ou seja, não possui kernel próprio, nem bibliotecas, nem binários, ele utiliza os da máquina host onde o docker foi instalado..</li>
    </ul>
    <p>Ver processos sendo executados pelo container: ps -ef</p>
    <p>SAIR DO CONTAINER:</p>
    <ul>
      <li>CUIDADO, ao clicar ctrl+d, você irá encerrar o container. Para sair do container, mas deixá-lo ativo, você digita ctrl+p+q.</li>
      <li>Você pode checar se o container ainda está rodando e que você apenas saiu dele é só digitar no terminal 'docker ps'</li>
      <li>Para voltar ao container digite: docker attach CONTAINER-ID</li>
    </ul>
    <p>Verificando as alterações feitas no container: docker diff CONTAINER-ID</p>
    
    <h3>Exemplo 1</h3>
    <p>Criar um container de um web server (NGINX), que irá exibir uma página mostrando que o programa funciona.Vamos lá!</p>
    <ul>
      <li>Criar o container: docker run -i -t -p 8080:80 ubuntu:14.10 /bin/bash</li>
      <ul>
        <li>-p == porta</li>
        <li>8080 = porta da máquina física (host)</li>
        <li>80 = porta do container</li>
        <p>Dessa forma, pegaremos a porta 80 do container que irá expor essa porta na porta 8080 do ip da máquina (host). Com isso, acessando num browser, ao digitar 8080 irá exibir a página do web server que estará instalada no container rodando na porta 80 do container.</p>
       </ul>
      <li>Instalar o NGINX: apt-get install nginx</li>
      <li>Para ver os processos funcionando: ps -ef</li>
      <li>Iniciar o NGINX: /etc/init.d/nginx start</li>
      <ul>
        <li>OBS: pela minha máquina não consegui inslar inicialmente, pois o container estava com problemas com o apt-get update. Resolvi através <a href="https://futurestud.io/tutorials/how-to-fix-ubuntu-debian-apt-get-404-not-found-repository-errors"> desse link. </a>  </li>
      </ul>
      <li>Podemos ver os processos do nginx através do comando: ps -ef</li>
      <li>Verificando se a porta 80 está 'escutando' (LISTEN)  no container: netstat -atunp</li>
      <li>Saia do container sem desligá-lo: ctrl+p+q</li>
      <li>Vá ao seu browser e digite SEU-IP:8080. Irá aparecer no broser a seguinte página:</li>
      <img src="nginx.png">
      <li>Se digitarmos docker diff CONTAINER-ID iremos perceber que foram feitas várias alterações no container. Se fecharmos com ctrl+d tudo que foi alterado será perdido. Para evitar isso vamos fazer um commit nessas modificações, criando uma imagem desse container. Para fazer isso vamos digitar docker commit CONTAINER-ID NOME_QUE_VOCE_DARA_A_IMAGEM/TITULO_E_VERSÃO</li>
      <ul>
        <li>No caso do exemplo, ficará assim: docker commit ff4e50247633 maria/nginx-ubuntu:1.0</li>
      </ul>
      <li>Podemos checar a imagem 'commitada' usando o comando docker images</li>
    </ul>
    
    <h3>Exemplo 2: criar um segundo container</h3>
    <p>Agora iremos um segundo container NGINX usando outra porta no host (6660)  para a porta 80 do container. Vamos lá!</p>
    <ul>
      <li>Suba o novo container com: docker run -i -t -p 6660:80 maria/nginx-ubuntu:1.0 /bin/bash</li>
      
      <li>Inicie o nginx: /etc/init.d/nginx start</li>
      <li>Cheque se o nginx está sendo executado: ps -ef</li>
      <li>Saia do container com ctrl+p+q</li>
      <li>Verifique se a imagem está listada: docker ps</li>
      <li>Vá ao browser e digite SEU-IP:6660. Irá aparecer a página do nginx respectiva a esse container que criamos.</li>
      <img src="nginx.png">
    </ul>
    <p>Se quisermos checar se realmente os acessos a página estão ocorrendo fazemos:</p>
    <ul>
      <li>Acesse o container: docker attach CONTAINER-ID</li>
      <ul>
        <li>No meu caso, esse comando não funcionou, o container travava, consegui rodar o container digitando: docker run -it IMAGE-NOME (docker run -it maria/nginx-ubuntu:1.0</li>
        <ul>
          <li><font color="red">Ajeitar essa parte, pois o comando run na verdade cria um novo container e a ideia é abrir um container já existente.OBS: <a href="https://github.com/moby/moby/issues/8521">resolvido aqui.</a></font></li>
        </ul>
      </ul>
      <li>Veja o log de acessos ao container: tail -f /var/log/nginx/access.log</li>
    </ul>
  <p>Por fim, se queremos parar um container: docker stop CONTAINER-ID</p>
  <p>Lembrando que sempre que quisermos abrir o container podemos fazer: docker run -ti IMAGE-NOME /bin/bash</p>
  
  <h2>Alguns Comandos:</h2>
  <h3>docker exec</h3>
  <p>Usado quando quisermos usar um comando dentro do container. Exemplos:</p>
  <ul>
    <li>docker exec CONTAINER-ID ps -ef</li>
    <li>Parando o nginx do container (caso exista): docker exec CONTAINER-ID /etc/init.d/nginx stop</li>
    <li>Iniciando o nginx: docker exec CONTAINER-ID /etc/init.d/nginx start</li>
  </ul>
  
  <h3>docker inspect</h3>
  <p>Permite ver detalhes sobre o container em execução.</p>
  <p>docker inspect CONTAINER-ID</p>
  <p>Com eles podemos ver o IP do container, as portas, a data em que o container foi criado, entre outras informações.</p>

  <h3>Ver a tela de boas vindas do nginx</h3>
  <p>Pegue o ip encontrado no docker inspect. Digite: curl NUMERO-IP:80</p>
  <p>Ou então pegue o ip do ifconfig. Digite: curl NUMERO-IP:8080</p>

  <h3>docker stats</h3>
  <p>Verifica o quanto o container está consumindo de CPU, memória e rede, se está sobrecarregando o host, etc </p>
  <p>docker stats CONTAINER-ID</p>
  <img src="stats.png">

  <h3>docker stop</h3>
  <p>Parar o container</p>
  <p>docker stop CONTAINER-ID</p>
  <p>OBS: não irá remover o container, você pode reacessá-lo com: docker start CONTAINER-ID</p>
  
  <h3>docker rm</h3>
  <p>Exclui o container da máquina.</p>
  <p>docker rm CONTAINER-ID</p>
  <p>É importante que paremos o container (docker stop) antes de removê-lo. Se quisermos forçar um container em execução a ser excluído, fazemos: docker rm -f CONTAINER-ID</p>
  
  <h3>docker rmi</h3>
  <p>Exclui a imagem do hd.</p>
  <p>docker rmi IMAGE-ID</p>
  <p>Antes:</p>
  <img src="rmi1.png">
  <p>Depois:</p>
  <img src="rmi2.png">
  <p>Se a imagem estiver em execução será preciso forçar: docker rmi -f IMAGE-ID</p>     
  
  <h3>Fazendo dois containers se comunicarem</h3>
  <p>docker run -it --name web2 --link CONTAINER-NAME:web1 REPOSITORY:TAG</p>
  <ul>
    <li>-it: interação + terminal</li>
  </ul>
  <p>No caso dos containers escolhidos por mim serão </p>
  <p>Às vezes não dará erro para criar algum container com um nome já usado antes, para isso, podemos remover em lote todos os containers não utilizado de uma só vez: docker container prune (caso deseje forçar a exclusão, insira -f)</p>
  <p>Para listar todos os conteineres não utilizados: docker container ls -a --filter status=exited --filter status=created </p>
  
  <h2>Criando imagens de container com Dockerfiles</h2>
  <img src="dfile.png"> 
  <p>Arquivo onde você coloca cada passo na criação de uma imagem de container. Lembra o makefile do linux.</p>
  <p>Por exemplo, se queremos usar uma imagem do Apache já no Dockerhub (na internet) e vamos imaginar que queremos colocar os arquivos do seu site dentro dessa imagem de container junto com suas configurações personalizadas. A melhor forma é criando um Dockerfile, que irá permitir criar uma imagem personalizada. Sabendo disso, vamos montar nosso Dockerfile.</p>
  <ul>
    <li>Crie um diretório de nome Dockerfile: mkdir Dockerfile</li>
    <li>Procure a pasta Dockerfile: cd Dockerfile</li>
    <li>Crie o diretório Apache: mkdir apache</li>
    <ul>
      <li>Importante: só é possível criar um Dockerfile por diretório.</li>
    </ul>
    <li>Dentro do diretório do apache digite: vim Dockerfile</li>
    <li>A primeira linha do Dockerfile é o FROM, que contem a imagem base que você vai utilizar para criar essa outra imagem.</li>
    <ul>
      <li>No nosso caso será: FROM ubuntu:14.04</li>
    </ul>
    <li>Próxima linha MAINTAINER: nome de quem criou o dockerfile </li>
    <ul>
      <li>No nosso caso será: MAINTAINER maria@email.com</li>
      <li>OBS: MAINTAINER é uma label <a href="https://cursos.alura.com.br/forum/topico-maintainer-deprecated-87916">depreciada</a>. O novo formato é LABEL mantainer="nome"</li>
    </ul>
    <li>Próxima linha RUN: comando que se deseja executar</li>
    <ul>
      <li>No nosso caso será: RUN apt-get update && apt-get install -y apache2 &&apt-get clean</li>
      <ul>
      <li>apt-get update: atualiza a lista de diretórios.</li>
      <li>-y: significa YES, é preciso usá-lo, para que confirme automaticamente a instalação do pacote.</li>
      <li>clean: limpa todos os pacotes durante a instalação, para deixar o container bem enxuto.</li>
      </ul>
      <ul>
        <li>OBS: para salvar e sair do VIM: esc+esc, depois :wq</li>
      </ul>
    </ul>
  </ul>  
  <h3>Construindo a imagem através do dockerfile (build)</h3>
  <p>IMPORTANTE: é preciso estar no diretório do dockerfile. Podemos checar isso vendo o caminho (path) atual com 'pwd' no terminal e depois pedindo para listar os arquivos com 'ls'. Se o arquivo existe irá aparecer listado ('Dockerfile'). Agora vamos lá! Criando a imagem:</p>
  <ul>
    <li>Criando a imagem: docker build .</li>
    <ul>
      <li>. = representa o nosso diretório atual.</li>
    </ul>
    <li>Confirmando que a imagem foi criada: docker images</li>
    <img src="dimg.png">
  </ul>
  <p>Perceba que não existe o nome do repositório nem a tag, e precisamos dessas informações para fazer o seu gerenciamento. Assim, quando fazemos o build, é melhor que já passemos esses parâmetros para facilitar a administração futura da imagem. Dessa forma, faremos assim:</p>
  <ul>
    <li>docker build -t maria/apache:1.0 .</li>
    <ul>
      <li>-t: tag</li>
      <li>maria/apache:1.0 = NOME-REPOSITÓRIO:VERSÃO</li>
    </ul>
    <p>Dessa forma, quando digitarmos no terminar 'docker images', nossa imagem irá aparecer com os parâmetros apropriados:</p>
    <img src="dimg2.png">
  </ul>
  <h3>Rodando o container que possui essa imagem</h3>
  <p>docker run -it maria/apache:1.0 /bin/bash</p>
  <p>Digitando 'ps -ef' perceberemos que o apache não está rodando.</p>
  <img src="napc.png">
  <p>Para iniciar o apache faremos: /etc/init.d/apache2 start</p>
  <p>Agora quando digitarmos 'ps -ef' veremos o apache listado:</p>
  <img src="apc.png">
  <p>Digite 'netstat -atunp' para checar se a porta 80 está disponível. Se está, o container está rodando o apache.</p>
  <p>Checando se o apache está funcionando e exibindo mensagem de boas vindas:</p>
  <ul>
    <li>Procure seu ip com 'ifconfig'</li>
    <li>Saia do container com ctrl+p+q, depois digite: curl NUMERO-IP</li>
    <p>Deverá aparecer a seguinte imagem:</p>
    <img src="wapc.png">
  </ul>  
  
  <h2>Gerenciando CPU para container</h2>
  <p>Esse gerenciamento pode ser feito inclusive com o container em execução, devido ao comando UPDATE.<p>
  <h3>Limitando a memória do container</h3>
  <p>Primeiramente, vejamos quanta memória um container consome:</p>
  <ul>
    <li>Abra um container qualquer. No nosso caso, abriremos o container debian: docker run -ti debian /bin/bash</li>
    <li>Vejamos a memória do host completo e não só do container: free -m</li>
    <ul>
      <li>No meu caso, o container não possuía o comando 'free -m' disponível, resolvi instalando o procps: apt-get update && apt-get install procps</li>
    </ul>
    <li>Saia do container com ctrl+p+q</li>
    <li>Digite: docker inspect CONTAINER-ID | grep -i mem</li>
    <ul>
      <li>-i = serve para ignorar a procura de forma case sensitive.</li>
    </ul>
    <p>O docker inspect trará informações sobre esse container. Vamos focar na linha 'Memory'. Nessa linha mostra o limite de memória do container. Se subirmos o container sem declarar nenhum limite, ele usará toda a memória disponível no root, ou seja, 0. </p>
    <img src="mem1.png">
    <p>Para limitarmos a memória do container, podemos fazer um desses comandos:</p>
    <ul>
      <li>docker run -ti -m 512M debian /bin/bash</li>
      <li>docker run -ti --memory 512M debian /bin/bash</li>
    </ul>
    <p>Quando sairmos do container e digitarmos 'docker inspect CONTAINER-ID | grep -i mem' veremos agora que a linha 'Memory" terá um valor delimitado de memória:</p>
    <img src="mem2.png">
    <p>Se deseja checar se o valor está correto, vá no basic calculator do terminal digitando 'bc' e divida o número informado na 'Memory' por 1024/1024</p>
  </ul>

  <h3>Limitando a CPU</h3>
  <p>Limitar a CPU é um pouco diferente, por isso, vamos usar 3 containers nesses exemplos.</p>
  <ul>
    <li>Container 1: docker run -ti --cpu-shares 1024 debian /bin/bash</li>
  </ul>
  <ul>
    <li>Container 2: docker run -ti --cpu-shares 512 debian /bin/bash</li>
  </ul>
  <ul>
    <li>Container 3: docker run -ti --cpu-shares 512 debian /bin/bash</li>
  </ul>

  <header></header>
  <main></main>
  <footer></footer>
  </body>
</html>
